var searchIndex = {};
searchIndex['ndarray'] = {"items":[[0,"","ndarray","The **ndarray** crate provides the [**Array**](./struct.Array.html) type, an\nn-dimensional container similar to numpy's ndarray.\n"],[3,"Si","","A slice, a description of a range of an array axis."],[3,"Indexes","","An iterator of the indexes of an array shape."],[3,"Array","","The **Array** type is an *N-dimensional array*."],[3,"Elements","","An iterator over the elements of an array."],[3,"ElementsMut","","An iterator over the elements of an array."],[3,"IndexedElements","","An iterator over the indexes and elements of an array."],[3,"IndexedElementsMut","","An iterator over the indexes and elements of an array."],[5,"ixrange","","Like `range`, except with array indexes."],[5,"arr0","","Return a zero-dimensional array with the element **x**."],[5,"arr1","","Return a one-dimensional array with elements from **xs**."],[5,"arr2","","Return a two-dimensional array with elements from **xs**."],[5,"arr3","","Return a three-dimensional array with elements from **xs**."],[0,"linalg","","A few linear algebra operations on two-dimensional arrays."],[5,"eye","ndarray::linalg","Return the identity matrix of dimension *n*."],[5,"least_squares","","Solve *a x = b* with linear least squares approximation."],[5,"cholesky","","Factor *a = L L<sup>T</sup>*."],[5,"subst_fw","","Solve *L x = b* where *L* is a lower triangular matrix."],[5,"subst_bw","","Solve *U x = b* where *U* is an upper triangular matrix."],[6,"Col","","Column vector."],[6,"Mat","","Rectangular matrix."],[8,"Ring","","Trait union for a ring with 1."],[8,"Field","","Trait union for a field."],[8,"ComplexField","","A real or complex number."],[11,"conjugate","","",0],[10,"sqrt_real","","",0],[11,"is_complex","","",0],[11,"conjugate","num::complex","",1],[11,"sqrt_real","","",1],[11,"is_complex","","",1],[11,"index","ndarray","Access the element at **index**.",2],[11,"index_mut","","Access the element at **index** mutably.",2],[11,"eq","","Return `true` if the array shapes and all elements of `self` and\n`other` are equal. Return `false` otherwise.",2],[11,"from_iter","","",2],[11,"hash","","",2],[11,"encode","","",2],[11,"decode","","",2],[11,"fmt","","Format the array using `Display` and apply the formatting parameters used\nto each element.",2],[11,"fmt","","Format the array using `Debug` and apply the formatting parameters used\nto each element.",2],[11,"fmt","","Format the array using `LowerExp` and apply the formatting parameters used\nto each element.",2],[11,"fmt","","Format the array using `UpperExp` and apply the formatting parameters used\nto each element.",2],[11,"ndim","collections::vec","",3],[11,"slice","","",3],[11,"slice_mut","","",3],[11,"remove_axis","","",3],[11,"fmt","ndarray","",4],[11,"hash","","",4],[11,"eq","","",4],[11,"ne","","",4],[11,"clone","","",4],[11,"clone","","",5],[11,"new","","Create an iterator over the array shape `dim`.",5],[11,"new1","","Create an iterator over the array shape `a`.",5],[11,"new2","","Create an iterator over the array shape `(a, b)`.",5],[11,"new3","","Create an iterator over the array shape `(a, b, c)`.",5],[11,"next","","",5],[11,"size_hint","","",5],[11,"clone","","",6],[11,"next","","",6],[11,"size_hint","","",6],[11,"next_back","","",6],[11,"clone","","",7],[11,"next","","",7],[11,"size_hint","","",7],[11,"next","","",8],[11,"size_hint","","",8],[11,"next_back","","",8],[11,"next","","",9],[11,"size_hint","","",9],[6,"Ix","","Array index type"],[6,"Ixs","","Array index type (signed)"],[17,"S","","Slice value for the full range of an axis."],[8,"Dimension","","Trait for the shape and index types of arrays."],[10,"ndim","","",10],[11,"slice","","",10],[11,"slice_mut","","",10],[11,"size","","",10],[11,"default_strides","","",10],[11,"first_index","","",10],[11,"next_for","","Iteration -- Use self as size, and return next index after `index`\nor None if there are no more.",10],[11,"stride_offset","","Return stride offset for index.",10],[11,"stride_offset_checked","","Return stride offset for this dimension and index.",10],[11,"do_slices","","Modify dimension, strides and return data pointer offset",10],[8,"RemoveAxis","","Helper trait to define a larger-than relation for array shapes:\nremoving one axis from *Self* gives smaller dimension *Smaller*."],[16,"Smaller","ndarray::RemoveAxis",""],[10,"remove_axis","ndarray","",11],[8,"ArrInit","","Slice or fixed-size array used for array initialization"],[10,"as_init_slice","","",12],[11,"is_fixed_size","","",12],[11,"clone","","",2],[11,"from_vec","","Create a one-dimensional array from a vector (no allocation needed).",2],[11,"from_iter","","Create a one-dimensional array from an iterator.",2],[11,"range","","Create a one-dimensional Array from interval **[begin, end)**",2],[11,"zeros","","Construct an Array with zeros.",2],[11,"from_elem","","Construct an Array with copies of **elem**.",2],[11,"from_vec_dim","","Create an array from a vector (with no allocation needed).",2],[11,"len","","Return the total number of elements in the Array.",2],[11,"dim","","Return the shape of the array.",2],[11,"shape","","Return the shape of the array as a slice.",2],[11,"is_standard_layout","","Return **true** if the array data is laid out in\ncontiguous “C order” where the last index is the most rapidly\nvarying.",2],[11,"raw_data","","Return a slice of the array's backing data in memory order.",2],[11,"slice","","Return a sliced array.",2],[11,"islice","","Slice the array's view in place.",2],[11,"slice_iter","","Return an iterator over a sliced view.",2],[11,"at","","Return a reference to the element at **index**, or return **None**\nif the index is out of bounds.",2],[11,"uchk_at","","Perform *unchecked* array indexing.",2],[11,"uchk_at_mut","","Perform *unchecked* array indexing.",2],[11,"iter","","Return an iterator of references to the elements of the array.",2],[11,"indexed_iter","","Return an iterator of references to the elements of the array.",2],[11,"isubview","","Collapse dimension **axis** into length one,\nand select the subview of **index** along that axis.",2],[11,"broadcast_iter","","Act like a larger size and/or shape array by *broadcasting*\ninto a larger shape, if possible.",2],[11,"swap_axes","","Swap axes **ax** and **bx**.",2],[11,"diag_iter","","Return an iterator over the diagonal elements of the array.",2],[11,"diag","","Return the diagonal as a one-dimensional array.",2],[11,"map","","Apply **f** elementwise and return a new array with\nthe results.",2],[11,"subview","","Select the subview **index** along **axis** and return an\narray with that axis removed.",2],[11,"ensure_unique","","Make the array unshared.",2],[11,"at_mut","","Return a mutable reference to the element at **index**, or return **None**\nif the index is out of bounds.",2],[11,"iter_mut","","Return an iterator of mutable references to the elements of the array.",2],[11,"indexed_iter_mut","","Return an iterator of indexes and mutable references to the elements of the array.",2],[11,"slice_iter_mut","","Return an iterator of mutable references into the sliced view\nof the array.",2],[11,"sub_iter_mut","","Select the subview **index** along **axis** and return an iterator\nof the subview.",2],[11,"diag_iter_mut","","Return an iterator over the diagonal elements of the array.",2],[11,"raw_data_mut","","Return a mutable slice of the array's backing data in memory order.",2],[11,"reshape","","Transform the array into **shape**; any other shape\nwith the same number of elements is accepted.",2],[11,"assign","","Perform an elementwise assigment to **self** from **other**.",2],[11,"assign_scalar","","Perform an elementwise assigment to **self** from scalar **x**.",2],[11,"sum","","Return sum along **axis**.",2],[11,"mean","","Return mean along **axis**.",2],[11,"row_iter","","Return an iterator over the elements of row **index**.",2],[11,"col_iter","","Return an iterator over the elements of column **index**.",2],[11,"mat_mul","","Perform matrix multiplication of rectangular arrays **self** and **other**.",2],[11,"mat_mul_col","","Perform the matrix multiplication of the rectangular array **self** and\ncolumn vector **other**.",2],[11,"allclose","","Return **true** if the arrays' elementwise differences are all within\nthe given absolute tolerance.<br>\nReturn **false** otherwise, or if the shapes disagree.",2],[11,"iadd","","Perform an elementwise arithmetic operation between **self** and **other**,\n*in place*.",2],[11,"iadd_scalar","","Perform an elementwise arithmetic operation between **self** and the scalar **x**,\n*in place*.",2],[6,"Output","",""],[11,"add","","Perform an elementwise arithmetic operation between **self** and **other**,\nand return the result.",2],[6,"Output","",""],[11,"isub","","Perform an elementwise arithmetic operation between **self** and **other**,\n*in place*.",2],[11,"isub_scalar","","Perform an elementwise arithmetic operation between **self** and the scalar **x**,\n*in place*.",2],[6,"Output","",""],[11,"sub","","Perform an elementwise arithmetic operation between **self** and **other**,\nand return the result.",2],[6,"Output","",""],[11,"imul","","Perform an elementwise arithmetic operation between **self** and **other**,\n*in place*.",2],[11,"imul_scalar","","Perform an elementwise arithmetic operation between **self** and the scalar **x**,\n*in place*.",2],[6,"Output","",""],[11,"mul","","Perform an elementwise arithmetic operation between **self** and **other**,\nand return the result.",2],[6,"Output","",""],[11,"idiv","","Perform an elementwise arithmetic operation between **self** and **other**,\n*in place*.",2],[11,"idiv_scalar","","Perform an elementwise arithmetic operation between **self** and the scalar **x**,\n*in place*.",2],[6,"Output","",""],[11,"div","","Perform an elementwise arithmetic operation between **self** and **other**,\nand return the result.",2],[6,"Output","",""],[11,"irem","","Perform an elementwise arithmetic operation between **self** and **other**,\n*in place*.",2],[11,"irem_scalar","","Perform an elementwise arithmetic operation between **self** and the scalar **x**,\n*in place*.",2],[6,"Output","",""],[11,"rem","","Perform an elementwise arithmetic operation between **self** and **other**,\nand return the result.",2],[6,"Output","",""],[11,"ibitand","","Perform an elementwise arithmetic operation between **self** and **other**,\n*in place*.",2],[11,"ibitand_scalar","","Perform an elementwise arithmetic operation between **self** and the scalar **x**,\n*in place*.",2],[6,"Output","",""],[11,"bitand","","Perform an elementwise arithmetic operation between **self** and **other**,\nand return the result.",2],[6,"Output","",""],[11,"ibitor","","Perform an elementwise arithmetic operation between **self** and **other**,\n*in place*.",2],[11,"ibitor_scalar","","Perform an elementwise arithmetic operation between **self** and the scalar **x**,\n*in place*.",2],[6,"Output","",""],[11,"bitor","","Perform an elementwise arithmetic operation between **self** and **other**,\nand return the result.",2],[6,"Output","",""],[11,"ibitxor","","Perform an elementwise arithmetic operation between **self** and **other**,\n*in place*.",2],[11,"ibitxor_scalar","","Perform an elementwise arithmetic operation between **self** and the scalar **x**,\n*in place*.",2],[6,"Output","",""],[11,"bitxor","","Perform an elementwise arithmetic operation between **self** and **other**,\nand return the result.",2],[6,"Output","",""],[11,"ishl","","Perform an elementwise arithmetic operation between **self** and **other**,\n*in place*.",2],[11,"ishl_scalar","","Perform an elementwise arithmetic operation between **self** and the scalar **x**,\n*in place*.",2],[6,"Output","",""],[11,"shl","","Perform an elementwise arithmetic operation between **self** and **other**,\nand return the result.",2],[6,"Output","",""],[11,"ishr","","Perform an elementwise arithmetic operation between **self** and **other**,\n*in place*.",2],[11,"ishr_scalar","","Perform an elementwise arithmetic operation between **self** and the scalar **x**,\n*in place*.",2],[6,"Output","",""],[11,"shr","","Perform an elementwise arithmetic operation between **self** and **other**,\nand return the result.",2],[6,"Output","",""],[11,"ineg","","Perform an elementwise negation of **self**, *in place*.",2],[6,"Output","",""],[11,"neg","","Perform an elementwise negation of **self** and return the result.",2],[11,"inot","","Perform an elementwise unary not of **self**, *in place*.",2],[6,"Output","",""],[11,"not","","Perform an elementwise unary not of **self** and return the result.",2],[11,"dim","","Return the base dimension of the array being iterated.",6],[11,"indexed","","Return an indexed version of the iterator.",6],[11,"dim","","Return the base dimension of the array being iterated.",8],[11,"indexed","","Return an indexed version of the iterator.",8],[11,"slice","","",10],[11,"slice_mut","","",10],[11,"size","","",10],[11,"default_strides","","",10],[11,"first_index","","",10],[11,"next_for","","Iteration -- Use self as size, and return next index after `index`\nor None if there are no more.",10],[11,"stride_offset","","Return stride offset for index.",10],[11,"stride_offset_checked","","Return stride offset for this dimension and index.",10],[11,"do_slices","","Modify dimension, strides and return data pointer offset",10],[11,"ndim","","",13],[11,"size","","",13],[11,"first_index","","",13],[11,"next_for","","",13],[11,"stride_offset","","Self is an index, return the stride offset",13],[11,"stride_offset_checked","","Return stride offset for this dimension and index.",13],[11,"remove_axis","","",13]],"paths":[[8,"ComplexField"],[3,"Complex"],[3,"Array"],[3,"Vec"],[3,"Si"],[3,"Indexes"],[3,"Elements"],[3,"IndexedElements"],[3,"ElementsMut"],[3,"IndexedElementsMut"],[8,"Dimension"],[8,"RemoveAxis"],[8,"ArrInit"],[6,"Ix"]]};
initSearch(searchIndex);
